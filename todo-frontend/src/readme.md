# Как провести вебинар

## Начало

Перед началом наставник говорит, что все молодцы, что учат Реакт. Реакт это про энтерпрайз и очень популярно. Что на митапах говорят языком реакта и в современном мире, на каком бы они потом стеке не писали, реакт им нужно понимать.

Повторяет что прошли:
1. Общий синтаксис реакта и JSX
2. Функциональные, классовые компоненты
3. Самые популярные хуки useState и useEffect
4. CRA и работу с ним

Говорит про цели вебинара:
0. сделать заготовку проекта, посмотреть на это глазами
1. показать, как разработчик, смотря на интерфейс, декомпозирует его на компоненты
2. написать компоненты
3. использовать хуки для хранения состояния и отправки GET-запросов на сервер

Все это пригодится в проектной работе

## Делаем заготовку проекта

1. Наставник напоминает команду глобальной установки CRA
2. Создает новое приложение через CRA
3. `npm i && npm start`

В этом блоке нужно просто все показать и напомнить команды, показать, как это выглядит наяву


## Смотрим интерфейс

Дизайн доступен по ссылке

https://www.figma.com/file/ytwxTpt91liWYpqU3VzOgn/react-live-01?node-id=0%3A1

Наставник комментирует, что интерфейс достаточно простой и механика понятная. Говорит, что поисковая строка будет получать данные с unsplash по запросу и показывает кабинет разработчика, откуда он взял ключ. Показывает доку, как этот GET-запрос будет формироваться. ТУТ ЖЕ УТОЧНЯЕТ, что на этом стриме мы не будем делать запрос из поисковой строки. Рабботу с формами они пройдут во втором спринте. Поэтому на этом вебинаре запрос мы захардкодим, а в следующем спринте доработаем.

Далее наставник разбирает дизайн на компоненты:

Рассказывает, что будет корневой App.js, собирающий всю логику и работающий с запросами к API через эффекты, туда будут импортироваться компоненты: Input, Button, Card. Лэйаут для них будет описан на уровне App.js, а стили самих компонентов в отдельных файлах. Говорит, что еще нужно подумать о прелоудере, который будет крутиться, пока запрос не вернул данные. Это тоже компонент. Назовем его Spinner.

Тут же наставник говорит о том, что весь CSS-код разбитый по компонентам у него уже готов, иначе вебинар бы длился долго. Тема вебинара — работать с реактом, он будет использовать готовые App.css, Card.css. Button.css, Input.css, Spinner.css

## Пишем код

Наставник удаляет все лишнее из бойлерплейта CRA, создает папку components и кидает туда заготовленные файлы стилей. App.css тоже добавляет как есть.

Далее создает разметку App.js, без импортированных компонентов, просто описывая зоны, куда встанут компоненты

Начинается разработка компонентов. Сначала идут Input.js и Button.js. Это простые функциональные компоненты. Но наставник подчеркивает особенность, что компоненты принято делать достаточно универсальными, чтобы они вставали в разные места проекта. Поэтому объясняет структуру пропсов: title и handleClick для Button, placeholder, handleChange для Input. Говорим, что хэндлеры нам потребуются позже. Для Button уже на этом вебинаре, а для инпута — на следующем. Не забываем импортировать стили в компонент и вставляем оба в App.js. Хэндлеры пока не прописывам.

Далее разбираемся с компонентом Card. Описываем его простой JSX в функциональном компоненте, объясняем пропсы: title, subtitle, alt, src. Указываем, что нам нужно получать список этих карточек из Api, для этого до импорта напишем все вспомогательное, чтобы мапить данные для карточек.

Говорим, что отправка запроса на сервер — отдельная логика, её можно описать нативно на JS и использовать этот интерфейс для реакт приложения. Поэтому написшем в папке api нативный ООП-класс, который будет фетчить данные по запросу и создавать экземпляр этого класса. Код внутри api/api.js. Импортируем этот файл в App.js и проговорим дальнейшую логику:

1. Нам нужно создать стейт компонента, в котором будет храниться ключевое слово запроса, со временем мы будем получать его из формы, пока захардкодим. Но нам понадобится хук useState, или придется переписать все на классовый компонент. Легче хуком.
2. Далее нам нужно взять состояние из стейта и отправить GET-запрос на сервер. Для этого нужен хук useEffect. Это достаточно традиционное его использование.
3. Далее, получив массив из апи, нам нужно создать через map новый массив объектов, в котором данные из api будут соответствовать заданным пропсам карточки. Этот массив нам тоже нужно положить в стейт компонента. А значит потребуется снова хук useState
4. На основе полученного массива из стейта мы будем отрисовывать список с карточками в JSX, передавая каждой карточке нужный пропс.

Далее наставник описывает эту функциональность:

```
const [searchQuery, setSearchQuery] = React.useState('');
const [cards, setCards] = React.useState([]);

React.useEffect(() => {

  api.search(searchQuery).then(data => {
    setCards(data.results.map((item) => ({
      id: item.id,
      src: item.urls.regular,
      alt: item.alt_description,
      title: item.description,
      subtitle: item.user.name,
    })));
  });
}, [searchQuery]);
```

Здесь нужно детально объяснять useEffect и его синтаксисб проговаривать весь фетч, что он делает и проговорить, почему важен второй аргумент хука.

В JSX:

```
cards.map(({ id, ...props }) => <Card key={id} {...props} />
```

Напоминаем про key, что он нужен, пусть пишут всегда с ним

Вспоминаем про хэндлер на кнопке и хардкодим:

```
<Button title="Search" handleClick={() => setSearchQuery('usa')} />
```

Приложение после этого должно работать, но остается вишенка на торте — спиннер. Создаем его JSX, подключаем готовый CSS. импортируем в App.js

Проговариваем логику его появления:

1. Должен существовать какой-то статус, что данные получены или нет. Это дело стейта компонента. Поэтому можно сразу написать useState-хук

```
const [isLoading, setIsLoadiing] = React.useState(false);
```

2. До всех фетчей в useEffect этот стейт должен быть false, а при успехе получения данных становиться true. Добавляем эти строчки в код useEffect

3. На уровне компнента напишем тернарный оператор, если isLoading вернет правду, вывести созданный список, в противном случае, показывать Spinner

Этот код финальный для этого спринта. Приложение работает.

## Повторяем

1. Сначала мы развернули CRA,
2. Потом оформили компоненты и спроектировали пропсы
3. Потом вынесли функциональность api в отдельный ООП-интерфейс
4. Написали хуки и функциональность в App
5. Вывели все на страницу

Наставник это все говорит своими словами и подчеркивает краеугольные моментв, которые у него появлялись в этом путешествии.


